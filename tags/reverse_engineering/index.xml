<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>reverse_engineering on Playhouse</title>
    <link>/tags/reverse_engineering/</link>
    <description>Recent content in reverse_engineering on Playhouse</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Oct 2021 13:00:00 +0100</lastBuildDate><atom:link href="/tags/reverse_engineering/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Redress v1.0.0 Released</title>
      <link>/posts/redress-v1/</link>
      <pubDate>Mon, 25 Oct 2021 13:00:00 +0100</pubDate>
      
      <guid>/posts/redress-v1/</guid>
      <description>It&amp;rsquo;s been over two years since the first public release of redress and a lot has changed since then. Redress has finally reached version 1.0. This release includes many surface and under the hood changes. One of the obvious changes is the user interface which has been rewritten to make it easier to use.
The Go Reverse Engineering Tool Kit (GoRE) has had a lot of improvements during the last few months and redress is taking advantage of these improvements.</description>
    </item>
    
    <item>
      <title>Tackle Inline Go Functions</title>
      <link>/posts/go-inline-code/</link>
      <pubDate>Sat, 02 Jan 2021 12:00:00 +0000</pubDate>
      
      <guid>/posts/go-inline-code/</guid>
      <description>The Problem Within the last few releases, the Go compiler has gotten better at inlining smaller functions. This can sometimes make it harder when analyzing an unknown Go binary with a disassembler. Instead of seeing a call to a documented library function, the library function&amp;rsquo;s code has been &amp;ldquo;merged&amp;rdquo; with the caller and it is easy to waste time trying to decipher the library code when just reading the documentation would have been faster.</description>
    </item>
    
    <item>
      <title>Time For Some Function Recovery</title>
      <link>/posts/pclntab-function-recovery/</link>
      <pubDate>Sun, 23 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/pclntab-function-recovery/</guid>
      <description>Time For Some Function Recovery Binaries compiled with the Go compiler includes a large set of metadata. This metadata can be used to assist static analysis of stripped binaries. Stripped binaries, especially statically compiled, are hard to analyze. Since the symbols have been removed and the huge number of subroutines, hello world binary in Go have thousands of subroutines, it can be very time-consuming. Fortunately, the metadata in the binary can be used to reconstruct symbols and also recover information about the source code layout.</description>
    </item>
    
    <item>
      <title>Say Hello to Moduledata</title>
      <link>/posts/hello-moduledata/</link>
      <pubDate>Sun, 16 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/hello-moduledata/</guid>
      <description>Say Hello to Moduledata The moduledata structure is a data table that was first introduced in version 1.5 of Go. It is a structure that holds important information that is needed when you statically analyzing Go binaries. It records information about the layout of the executable. For ELF binaries, the structure can be found in the .noptrdata section. In PE files it is much harder to find. Sometimes it is located in the .</description>
    </item>
    
    <item>
      <title>Malware Analysis using Malboxes</title>
      <link>/posts/malware-analysis-using-malboxes/</link>
      <pubDate>Mon, 30 Apr 2018 10:59:00 +0100</pubDate>
      
      <guid>/posts/malware-analysis-using-malboxes/</guid>
      <description>A while back I came across two projects that automate the creation of virtual machines for malware analysis. The original open source project what uses Packer and Vagrant to bootstrap a malware lab can be found here. As part of this blog post, I will instead use malboxes from GoSecure as it suits my need more.
Malboxes creates a Windows VM template using packer. The template will have tools installed. Every time a new malware is analyzed, a new VM is created using vagrant.</description>
    </item>
    
  </channel>
</rss>
